# IT-Purple-Hack-Avito-Pricing-service
Сервис отдачи цен для платформы ценообразования Avito в рамках хакатона IT Purple Hack

## Описание
Мы разработали MVP приложения с клиент-серверной архитектурой с использованием веб-сервера. Где клиент это веб-интерфейс административной панели,
а сервер - сервер отдачи цен, обеспечивающий обработку запроса цены от клиентов и предоставляющего api для административной панели. Со стороны бекенда были реализованы все реквесты([Requests.md](Requests.md)).
Со стороны фронтенда имеются все функции на запросы, но из-за коротких сроков результаты не всех мы можем видеть на экране.
Имеется подготовленный инстанс контейнера Reddis для кеширования данных, но не встроеннный в проект.

---
Отдача цены происходит следующим образом. 
Так как скидочные матрицы покрывают гораздо меньше чем базовые, можно оптимизировать roadUpSearch, чтобы не делать его по веткам,
в нодах которых нет даже записей в матрице, и при поднятии вверх переходить сразу на ноду имеющую запись для дальнейшней проверки.
В графовой для каждого дерева лежат дополнительные ноды, содержащие номер матрицы и h - расстояние до ближайшей живой(имеющей запись в матрице)
родительской ноды. Заполнение происходит обходом в глубину: проносим массив h (чтобы для каждой матрицы), сначала они равны -1, если нода есть
в матрице, тогда h++, уходим в рекурсию. Если ноды нет в таблице и h>0 => h++ и проносим ее дальше, если есть в таблице, то записываем h, зануляем и проносим дальше. 
Делаем так для деревьев локаций и категорий и получаем две заполненных таблицы (в графовой бд рядом с деревьями) ускоренного обхода с пропущенными мертвыми ветками.

Пусть от клиента есть пара категория-локация, тогда обращаемся к таблицам ускоренного обхода локаций и категорий, если хоть один h = -1, то мы точно не найдем пару в матрице, 
иначе делаем RoadUpResearch с прыжками.
Если происходит добавление/удаление цены через аналитика, то происходит пересчет расстояний.

---

## Технологии

### Frontend: React / JS

Мы выбрали данную технологию в силу гибкости и эффективности в создании пользовательсикх интерфейсов фреймворка.

### Backend: Java / Spring

Выбор технологий обусловлен следующими причинами:

- Надженость и Масштабируемость - Java в сочетании со Spring позволяет создавать надежные и масштабируемые системы 
- ORM/OGM - Spring Data JPA предоставляет удобную ORM/OGM для взаимодействия с базами данных

### Базы данных: Postgresql и Neo4j

**Postgresql** - реляционная бд, которую мы используем для хранения скидочных и базовых матриц. Данная база данных является
надежным хранилищем даннных и предоставляет большие возможности для создания логического реплицирования 
данных между несколькими развернутыми экземплярами, что позволило нам достичь персистентности хранения цен 



**Neo4j** - графовая бд, которую мы используем для хранения дереьев локаций и категорий.
Намного быстрее отвечает на запросы по сравнению с другими реляционными базами данных. 
У него нет накладных расходов на сложные объединения, а его оптимизация хорошо работает при большом размере набора данных
и высокой степени связанности. Он предлагает преимущество хранения графов наряду со свойствами ACID реляционной базы данных.
Такой выбор позволяет ускорить операции по перемещению между нодами графа, что дает больший выигрыш по скорости запросов к backend'у.

## API

API, предоставляемое backend сервисом, описано в файле [Requests.md](Requests.md)

## Развертывание

Для развертывания нашего приложения Мы используем технологию **Docker-Compose**,
позволяющую развертывать все необходимые экземпляры контейнеров для корректной работы приложения одной командой
с возможностью задания тонкой конфигурации каждой сущности.  

Данная технология позволила нам созадвать несколько реплик backend сервисов с равномерным распределением запросов между 
ними для большего быстродействия и распределенности системы, что обеспечивает устойчивость к разделению. В силу того, что backend сервисы не хранит какое либо состояние, 
ответсвенность за персистентность данных перекладывается на базы данных.

Для персистентности хренения цен в реляционной бд Мы использовали механизм логического реплицирования, 
при котором результат всех транзакций, проходящих на master ноду бд, копируется на реплики.


Инструкция по развертыванию находится в директории `/deploy`.

